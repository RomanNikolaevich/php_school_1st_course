<?php
// PHP с нуля - 1 урок - Основы языка и синтаксиса
1-1
/*
* Если нам нужно, чтобы часть кода ниже команды перестала обрабатываться, то мы прописываем следующее:
* <?php exit; ?>
*/
1-2
/*
* echo 'Hello World';
* echo - значит вывести на экран, 'это то что мы хотим вывести на экран', а ';' - это значит мы закончили команду.
*/
1-3
/*
 * Правило №1 текст выводится в кавычках '', а цифры без кавычек.
 * Если цифры часть текста, то тоже в кавычках.
 * 		echo '<b>Hello World</b>';
 *		echo  321;
 */
1-4
/*
 * Математические операции пишем в скобках:
 * echo (1+1);
 */
1-5
/*
 * Можно в начале кода прописать переменные, а потом где-то в середине им пользоваться, например:
 * <?php $num=7;
 * $text = 'Hello World'
 <?php echo $text?>
*/
1-6
/*
 * Правило програмирования №2:
 * PHP выполняется сверху вниз, слева на право!
 * Например: echo $text3; $text3 = 'Vasya'; - не правильно!
 * Правильно: $text3 = 'Vasya'; echo $text3;
 */
1-7
/*
 * Правило №3 РНР код всегда выполняется с нуля, с нулевой строчки кода!
 * То есть если у клиента открылась страница, код считался, то он и будет отображаться
 * а если часть кода скрыть, то при повторном запросе /обновлении страницы  - выдаст ошибку по этому коду!
 */
1-8
/*
 * РНР код можно сократить - вместо: <?php echo $title; ?>
 * можно записать: <?=$title;?> - это короткая запись по выводу команды
 */


// PHP с нуля - 2 урок - работа сервера, переменные, типы данных
// Урок 2: Углубляемся в типы данных и переменные

2-1
/*
 *После запроса от сервера к пользователю приходит только HTML, а РНР выполняется на стороне сервера и отправлояет сгенерированный HTML! Всего кода, что мы пишем на РНР - в браузере клиента его нет.
 * РНР - это серверный язык программирования, потому что он выполняется на сервере, где лежит сайт.
 */


2-2 // Чтобы положить информацию в файл пишем:
file_put_contents('1.txt', $text);
// достаем информацию из файла так:
$text = file_get_contents(filename:'1.txt');
echo $text;
//Но можно еще сократить вывод, одной строчкой:
echo file_get_contents('1.txt');


2-3 //Если два раза написать переменную, но каждый раз с разными значениями, то на экран пользователя выведется последння
 	$text = 'Hello World';
	$text ='Zimbabve'; //заменит значение переменной
//Но если перед знак присвоения поставить точку в последней пееременной, то выведутся оба текста вместе, например:
 	$text = 'Hello World';
	$text.=' Zimbabve'; //объединяется

//Следующий вариант - треться строчка затрет две предыдущие:
 	$text = 'Hello World';
	$text.=' Zimbabve';
	$text='Vasyan'; // выведется на экран только новое значение переменной - Vasyan

2-4 //Если у нас в HTML встречаются несколько переменных с одинаковым названием, то можно использовуать константы, например
$text = 'Вступительный урок'; /*эта запись не нужна теперь - для ознаколмления написана*/
define('TEXT', 'Вступительный урок') /*define - константа, ТЕХТ большими буквами*/
/* <h1><?=TEXT; ?></h1>
 * помещаем константу в HTML
 * Константой мы утверждаем настройки, котрые не будем менять в коде.
 */

2-5 // Типы переменных:
$text = 'Произвольный текст'; // string - строка, текст
$num = 10; // int, integer - целые числа
$float = 1.2; //float - дробные, с плавающей запятой
$bool = true; // bool, boolean (true или false)

$result = $text + $num; //выдаст ошибку, так как разные типы переменных складывать нельзя!
echo $result;
$result = $text.$num.$float //не выдаст ошибку, так как с точкой не складывает, а склеивает все подряд в одно слово
echo $result; //Произвольный текст101.2
$result = $text.' '.$num.' '.$float // тоже не выдаст ошибку + поставит между значениями переменных пробелы
echo $result; //Произвольный текст 10 1.2

//Пример:
$num1 = 10;
$num2 = 15;
$calc_result = $num1 + $num2; // или $calcResult - тоже самое "Верблюжий стиль"
var_dump($calc_result); //вывод на экран результатов - int(25)

$calc_result = $num1 / $num2; // тоже , только с делением
var_dump($calc_result); // float(0.6666666666666666) -число с плавающей запятой

//Приведение к типам - пример:
$num1 = (string) $num1; // вместо числа задаем новую переменную - строка
var_dump($num1); // получим string(2) "10" - число превратили в текст, в скобках указано количество знаков, байт

$num1 = (bool) $num1; // еще вариант
var_dump($num1); // bool(true) - правда все кроме нуля, даже с минусом правда (true)

/*
 * Допускаются следующие приведения типов:
(int), (integer) - приведение к int - целые числа
(bool), (boolean) - приведение к bool - логический
(float), (double), (real) - приведение к float - дробные числа
(string) - приведение к string - строка
(array) - приведение к array - множество, массив
(object) - приведение к object - объект
(unset) - приведение к NULL  — удаляет переменную
 */


// PHP с нуля - 3 урок - Управляющие конструкции и операторы сравнения
// Урок 3: Управляющие конструкции и операторы сравнения

3-1
/*
 * условия:
 * == равенство по значению - не путайте = и == в коде! В операторах сравнения не существует одного равно, это обычное присвоение переменной значения. А значение присваивается ВСЕГДА. И это распространённая ошибка, новички путают = и ==.
 * === равенство по значению и ТИПУ
 * != не равно
 * !== не равенство по значению или типу
 * < меньше
 * > больше
 * <= меньше или равно
 * >= больше или равно
 */
// Управляющие конструкции - if, elseif, else. Своимм словами:
// if (или так), elseif (или тоже так, но с другми условиями), else (или по другому совсем)
//Расмотрим на примере корзины добавления товара в интернет магазине: первый вариант:
$cart_count = 0;
if ($cart_count >0) { // если больше нуля
	echo 'В корзине '.$cart_count.' товаров';
	}
else { //если нет
	echo 'Нет товаров в корзине';
}

//второй вариант - меняем местами строчки:
$cart_count = '3';
if ($cart_count ==0) { // если да?
	echo 'Нет товаров в корзине';
}
else { //если нет
	echo 'В корзине '.$cart_count.' товаров';
}
 //третий вариант - с текстом:
$cart_count = 'Пиво';
if ($cart_count == 0) { // строка при переводе в число - превращается в ноль,
	// как вариант можно записать так: if ((int)$cart_count == 0)
	//ответ при == будет да, если  === то нет
	echo 'Да';
}
else { //если нет
	echo 'Нет';
}

// для уменьшения кода можно писать иногда без else :
$is_buy = 1;
if ($is_buy === (3-2)) // можно так же записать в виде:
	//if (true)
	echo 'Yes';

3-2
//Разбор вариантов с окончанием слов в корзине
//0 рублей
//1 рубль
//2 рубля
//первый вариант:
$rub = 2;
if ($rub === 0) {
	echo $rub.' рублей';
} else {
	if ($rub === 1) {
		echo $rub.' рубль';
	} else {
		echo $rub.' рубля';
	}
}
//второй вариант - с использованием elseif - пишем когда нужен дополнительный вариант условия if:
$rub = 3;
if ($rub === 0) {
	echo $rub.' рублей';
} elseif ($rub === 1) {
	echo $rub.' рубль';
} elseif ($rub === 2) {
	echo $rub.' рубля';
} else {
	echo $rub. ' рубл...';
}
/*
 * в этих схемах if - обазательно
 * elseif и else - не обязательно
 */

//Разберем на примере авторизации на сайте:
$login = 'inpost';
$pass = 'test';
if($login == 'inpost') {
	echo 'Логин совпал'; //условие верно
	} elseif($pass == 'test') {
	echo 'пароль совпал'; // условие верно
} else {
	echo 'Ни логин ни пароль не совпали'; // условие не верно
}

//второй вариант: тоже только на оборот, со знаком не равенства:
$login = 'inpost';
$pass = 'test';
if($login != 'inpost') {
	echo 'Логин не совпал'; //условие не верно
} elseif($pass != 'test') {
	echo 'пароль не совпал'; // условие не верно
} else {
	echo 'Логин и пароль совпали'; // условие не верно
}
// третий вариант:
$login = 'inpost';
$pass = 'test';
if($login == 'inpost') {
	if($pass == 'test') {
		echo 'Вы авторизированы';
	}
	else {
		echo 'Пароль введен не верно';
	}
} else {
	echo 'Логин введен не верно';
}

3-3
//Сравнение цифровых значений:
$num1 = 10;
$num2 = 5;
if($num1 != $num2) {
	echo 'не равно';
}

3-4
// Правило №4: работаем переменными из-вне только тогда, когда они существуют.

3-5 // isset — Определяет, была ли установлена переменная значением, отличным от null
//Определяет, была ли установлена переменная значением отличным от null.
//Если переменная была удалена с помощью unset(), то она больше не считается установленной.
$x = 1;
$y = 2;

if (isset($z)) { //переменная isset проверяет есть ли переменная и только если она есть, то выполняется этот блок
	echo 'Переменная существует';
} else {
	echo 'Переменная не существует';
}

3-6 //Работаем с формой в PHP:
// разберем на примере авторизации на сайте (html код закоментим, чтобы не мешал, но на странице сайта он должен быть не закоментен):
/*<form action="" method="post" class="content">
*	<input name="login" placeholder="Введите логин"><br>
*	<input name="password" placeholder="Введите пароль"><br>
*	<input type="submit" value="Отправить">
*</form>*/

//$_POST['login'];
//$_POST[['password'];
if(isset($_POST['login'], $_POST['password'])) {
	echo 'Форма была отправлена<br>';
}
//первый вариант:
if ($_POST['login'] == 'inpost') { // логин мы задаем заранее
	if($_POST['password'] == '123') { // пароль мы задаем заранее
		echo 'Вы ввели логин и пароль правильно, вы авторизированы<br>';
	}
}
//второй вариант - сокращаем два условия через && - обозначает "и":
if ($_POST['login'] == 'inpost' && $_POST['password'] == '123') {
	echo 'Вы ввели логин и пароль правильно<br>';
}

//третий вариант через || - обозначает "или":
if ($_POST['login'] == 'inpost' || $_POST['password'] == '123') {
	echo 'Вы ввели логин или пароль правильно<br>';
}

// четвертый вариант, когда достпен 1 вариант логина и два варианта пароля "123" или "234":
if ($_POST['login'] == 'inpost' && ($_POST['password'] == '123' || $_POST['password'] == '234')) {
	echo 'Вы ввели логин и пароль правильно<br>';
}
/* Эти блоки потом можно вставить в шапку сайта перед <a><Авторизация/a> и заменить на приветствие "Здравствуйте inpost"
 * Если логин и пароль верны, то пользователя по привествует, если нет, то перейдет к ссылке/кнопке "Авторизация"
 */

3-7
// Правило №5 Мы не используем exit на сайте, кроме как ОТЛАДКА КОДА;

3-8
//Функция empty -
$x = 1; //0 или пустая строчка - это false, 1, любой текст и далее true
if(empty($x)) {
	echo 'Переменная НЕ СУЩЕСТВУЕТ или она ПУСТАЯ';
}
if(!empty($x)) { // ! перед функцией означает, что будет выпоняться обратная функция
	echo 'Переменная и существует и она НЕ пустая';
}

3-9
//PHP supports the following data types: / PHP поддерживает следующие типы данных:
//String - строка
//Integer - Целое число
//Float (floating point numbers - also called double) - числа с плавающей запятой, также называемые двойными
//Boolean - логический
//Array - Множество / массивы
//Object - Объект
//NULL - нулевой
//Resource - ресурс

/*
 * Строка — это последовательность символов, например «Hello world!».
Строка может быть любым текстом в кавычках. Вы можете использовать одинарные или двойные кавычки
 */

/*
 * Целочисленный тип данных — это недесятичное число от -2 147 483 648 до 2 147 483 647.
Правила для целых чисел:
Целое число должно иметь хотя бы одну цифру
Целое число не должно иметь десятичной точки
Целое число может быть как положительным, так и отрицательным
Целые числа могут быть указаны в: десятичной (по основанию 10), шестнадцатеричной (по основанию 16), восьмеричной (по основанию 8) или двоичной (по основанию 2) нотации.
 */

/*
 * Float - Поплавок (число с плавающей запятой) — это число с десятичной точкой или число в экспоненциальной форме.
 */

/*
 * Булево значение PHP
Логическое значение представляет два возможных состояния: TRUE или FALSE. Логические значения часто используются в условном тестировании.
 */
/*
 * PHP-массив
Массив хранит несколько значений в одной переменной.
 */

/*
 * PHP-объект
Классы и объекты — два основных аспекта объектно-ориентированного программирования.
Класс — это шаблон для объектов, а объект — это экземпляр класса.
Когда создаются отдельные объекты, они наследуют все свойства и поведение класса, но каждый объект будет иметь разные значения свойств.
Предположим, у нас есть класс Car. Автомобиль может иметь такие свойства, как модель, цвет и т. д. Мы можем определить такие переменные, как $model, $color и т. д., чтобы хранить значения этих свойств.
При создании отдельных объектов (Volvo, BMW, Toyota и т. д.) они наследуют все свойства и поведение класса, но каждый объект будет иметь разные значения свойств.
Если вы создадите функцию __construct(), PHP будет автоматически вызывать эту функцию при создании объекта из класса.
 */

/*
 * НУЛЕВОЕ значение PHP
Null — это особый тип данных, который может иметь только одно значение: NULL.
Переменная типа данных NULL — это переменная, которой не присвоено значение.
Совет: Если переменная создается без значения, ей автоматически присваивается значение NULL.
Переменные также можно очистить, установив значение NULL
 */

//Урок 4: Массивы
/*План:
*Массивы
*Элементы массива
*CRUD массивов и элементов массива
 *
 * Словарь:
 * Массивы (array) - тип данных, позволяющий группировать переменные.
 * Элемент массива (element) - одна переменная в массиве
 * Ключ (key) - имя элемента массива (имя переменной, по аналогии)
 * Индексный ключ (index) - порядковый номер (int)
 * Ассоциативный ключ (assoc) - текстовое имя (string)
 * Значение (value) - содержание элемента массива
 */

4-1
//МАССИВ
//СОСТАВ МАССИВА: КЛЮЧ => ЗНАЧЕНИЕ, (при этом ЗНАЧЕНИЕ обязательно, а КЛЮЧ НЕТ)
// переменная => значение
//разберем на примере массива - оценки учеников:
{
	$vasya = 5; //ключ = значение (key = value)
	$petya = 4;
	$nastya = 2;
}
// каждая переменная (ключ) в массиве называется: элемент массива
//пишем этот же пример на php:
$users = [
	'vasya' => 5, //переменные выделяем '_' вместо $,так же используем запятую в конце строки, вместо точки с запятой
	'petya' => 4,
	'nastya' => 2,
];
echo '<pre>'; //задаем для красивого вывода - в столбик
//var_dump($users); - выводим данные на экран раньше мы так учили, но это функция отладки, пока отключим
// для вывода на экран лучше использовать print_r
print_r($users); // так и вид лучше

//массив в массиве пример:
$elements = [
	'russia' => [
		'Saint peterbuerg',
		'Moscow',
	],
	'Ukraine' => [
		'Kiev',
		'Sumy',
		'Hlukhiv',
	]
];
echo '<pre>'; // это сейчас пишем, чтобы посмотреть как будет выглядеть при разработке
print_r($elements); //а в реальном коде уже не используем

4-2 //Как дополнить массив?
$country = [
	'Russia',
	'Ukraine',
];
$country[] = 'Israel'; // вот так дополняем массив
// еще пример - наш массив с оценками в школе:
$users = [
	'vasya' => 5,
	'petya' => 4,
	'nastya' => 2,
];
// 1) можем добавить ученика:
$users ['dima'] = 4;
print_r($users); // на экране мы уже увидим [dima] => 4 внутри массива с остальными.
// 2) можем перезаписать данные:
$users ['nastya'] = 3; // Так как 'nastya' уже есть в массиве, то 2 перезапишется на 3
// 3) можем всем поднять на один бал оценки:
++$users['nastya']; // так только Насте
// чтобы поднять всем оценки - нужно использовать циклы (будем изучать в следующем уроке)

//Числовой массив [не задается] называется - индексный.
//А когда ключ имеет [имя] - ассоциативный.

4-3 //чтобы удалить переменную используется следеющая команда (пишется после массива):
unset($elements);

//чтобы удалить определенную строчку с массива пишем:
unset($users ['vasya']); // удаляем имя 'vasya' из массива
unset($country [1]); // или порядковый номер записи (отсчет начинается с нуля)

4-4 // вывод переменной:
echo ($users ['petya'] * $users ['nastya']); // Петя 4 * Настя  2 получим вывод на экран "10"

//вывод из вложенных массивов:
echo $elements ['russia'][1]; //выведется 'Moscow'

// еще один вариант через временный файл?
$tmp = 'russia';
echo $elements [$tmp][1];

4-5 // implode — Объединение массивов в строку:
$country = [
	'Russia',
	'Ukraine',
	'Israel',
];
$countries = implode (  ', ', $country); //implode — Объединяет элементы массива в строку
/*добавляем в html полученную переменную:
* <p> Мы работаем со странами: <?=$countries;?>.</p>
* на экран выдаст текст "Мы работаем со странами: Russia, Ukraine, Israel."*/


4-6 // explode — Разбивает строку с помощью разделителя:
$tags = 'php mysql array variable';
$tags_array = explode(' ', $tags); //преобразовываем набор слов в массив
echo '<pre>';
print_r($tags_array); // выдает на экран массивом эти данные


// 10-й урок Урок 10: Практикуемся с версткой

10-1
// новая функция: switch
/*
 * Оператор switch похож на ряд операторов IF с одинаковым условием. Во многих случаях вам может понадобиться сравнивать
* одну и ту же переменную (или выражение) с множеством различных значений и выполнять различные участки кода в
* зависимости от того, какое значение принимает эта переменная (или выражение). Это именно тот случай, для которого
* удобен оператор switch.
 */
switch($path) {
	case 'main': //условия
		//сюда прописываем действия (echo или любое другое)
		break;
	case 'payment': //условия
		break; //действия
	default: // - пишем, если ниодно действие не совпало
		$page = 'main';
}
//сокращенный вариант:
switch($page) {
	case 'main': case 'payment': //условия
		//сюда прописываем действия (echo или любое другое)
		break;
	default: // - пишем, если ниодно действие не совпало
		$page = 'main';
}

// пишем такую же конструкцию через if:
if($page == 'main') {
	//действия
} elseif($page == 'payment') {
	//действия
} else { // - пишем, если ниодно действие не совпало
	$page = 'main';
}
// эту конструкцию тоже можем сократить:
if($page == 'main' || $page == 'payment') {
	//действия
} else { // - пишем, если ниодно действие не совпало
	$page = 'main';
}
// расшифровка: если переменная $page не является 'main' или 'payment', то мы ее сделаем 'main'

10-2
// include - эта функция включает и выполняет указанный файл (указывает какой файл нужно запустить и какие
// переменные оттуда вытянуть или может все содержимое страницы подгрузить с того файла в наш)
vars.php // отсюда берем информацию
<?php
$color = 'зелёное';
$fruit = 'яблоко';
?>

test.php
<?php
echo "Одно $color $fruit"; // Одно
include 'vars.php'; // сюда подключаем
echo "Одно $color $fruit"; // Одно зелёное яблоко
?>

<?php
// 11-й урок массивы и циклы

11-1 // Массивы
$country = array();
$country [] = 'Chaos name 1';
$country [] = 'Chaos name 2';
$country [] = 'Chaos name 3';
$country [] = 'Chaos name 4';

echo '<pre>'.print_r($country,2).'</pre>'; // вывод на экран
unset($country[2]); // удаляем из массива 2 строчку
// (отсчет идет с 0, поэтому реально это 3-я строчка 'Chaos name 3)
echo '<pre>'.print_r($country,2).'</pre>'; // вывод на экран, предыдущая информация не стирается
$country [] = 'Chaos name 5'; // добавляем новую строчку
echo '<pre>'.print_r($country,2).'</pre>'; // вывод на экран, предыдущая информация не стирается
// как видим новая строчка не заняла место 2-й удаленной, а стала 4-й. Каждая новая, не учитывает удаленные,
// а присваивает номера дальше

//Вывод из массива данных на экран:
$var = 'Произвольный текст';
$array = array (
	'key'=>'value',
	'key2'=>'value2',
	'key3'=>'value3',
	'names'=>array('Вася', 'Петя', 'Илона', 'Даша'),
);
echo '<pre>'.print_r($array,1).'</pre>'; // это команда для просмотра структуры массива
echo $array['names'][1]; // На экран вывелся 'Петя'
//кроме print_r есть еще одна функция: var_damp - она отличается от предыдущей тем, что указывает
// дополнительно типы данных и (длину строки) - более профессиональный, но менее удобный.
echo '<pre>';
var_dump($array);
echo '</pre>';

11-2 /* Циклы
 1. while
 3. do-while
 3. for
 4. foreach (для массивов)
 */

11-2-1 //Какой цикл быстрее и почему?
while //- перебирает блок кода до тех пор, пока заданное условие истинно. Циклический просмотр блока кода до тех пор, пока выполняется заданное условие. Для этого лучше while.
	//Все эти циклы используют мало ресурсов, поэтому мы не замети проблему с ними.
do...while //- проходит через блок кода один раз, а затем повторяет цикл до тех пор, пока заданное условие истинно
for // - перебирает блок кода указанное количество раз. Используется для счетчика, сделать какое-то определенное количество раз определенное действие. Для данного случая будет быстрее for.
foreach //- перебирает блок кода для каждого элемента массива. Используется для обхода массива! Он быстрее всего обходит массив.


11-2-2 /* Сравнение циклов через решение одной и той же задачи:
	Условие - нужно вывести на экран следующее:
	The number is: 1
	The number is: 2
	The number is: 3
	The number is: 4
	The number is: 5 */

//с помощью while:
$x = 1;
while($x <= 5) {
	echo "The number is: $x <br>";
	$x++;
}

// с помощью do... while:
$x = 1;
do {
	echo "The number is: $x <br>";
	$x++;
} while ($x <= 5);

//с помощью for:
for ($x = 1; $x <= 5; $x++) {
	echo "The number is: $x <br>";
}

//с помощью foreach:
$numbers = array("The number is: 1", "The number is: 2", "The number is: 3",
	"The number is: 4", "The number is: 5");
foreach ($numbers as $x) {
	echo "$x <br>";
}
//верхний пример foreach можно написать через функцию:
function num($numbers = array("1", "2", "3", "4", "5")) {
	foreach ($numbers as $x) {
		echo "The number is: $x<br>";
	}
}
num ();

11-2-3a // while - принцип написания похож на if
//Если нужно производить выполнение операторов цикла в PHP скрипте только при выполнении определённого условия, то в PHP используется цикл while
//Синтаксис цикла while в PHP
while(условие)
{
	Операторы цикла через ;
     }
//  "=" - это не равно, а базовый оператор присвоения, устанавливает значение
//"==" - это уже равно, "===" - тождественно равно (переменные равны и имеют тот же тип)
$x = 1;
echo $x.'Текст до цикла<br>'; // выведется: '1Текст до цикла'
while($x == 1 || $x == 2 || $x == 3) {
	echo 'Произвольный текст';
	$x = $x + 1; // увеличиваем переменную на 1 вплоть до 4
	//можно так же сократить это же выражение:
	// ++$x;
	echo $x.'<br>'; // выведется: 'Произвольный текст2', и так далее до 'Произвольный текст4'
}
echo 'Текст после цикла'.$x; // выведется последняя строчка: Текст после цикла4

//Операторы инкремента и декремента
//++$a	Префиксный инкремент	Увеличивает $a на единицу, затем возвращает значение $a.
//$a++	Постфиксный инкремент	Возвращает значение $a, затем увеличивает $a на единицу.
//--$a	Префиксный декремент	Уменьшает $a на единицу, затем возвращает значение $a.
//$a--	Постфиксный декремент	Возвращает значение $a, затем уменьшает $a на единицу.


//второй вариант:
$x = 1;
echo 'Текст до цикла<br>';
while($x < 10) {
	echo $x.'Произвольный текст<br>'; // выведется 9 раз
	++$x;
} echo 'Текст после цикла'.$x;

// тот же второй вариант, только уже в html в виде таблицы:
$x = 1;
echo '<table border=1"><br>';
while($x < 10) {
	echo '<td>';
	echo $x.') Произвольный текст<br>'; // выведется 9 раз
	++$x;
} echo '</td>';


//Использование цикла while более корректно для поиска корней уравнения, потому что мы изначально не знаем, в каком диапазоне находится корень,  а использование цикла for предполагает, что мы это знаем.
//Пример скрипта на PHP с использованием цикла while. Скрипт ищет решение уравнения x²-20x+100=0
    $y = 100;
    $i = 0;
    while($y != 0) {
		$i = $i + 1;
		$y = $i * $i - 20 * $i + 100;
	}
   echo "Решение уравнения {$i}"; //Решение уравнения 10

// Рассмотрим дальше на примере одной и той же таблицы, на html и с помощью циклов:
/* тут два ряда в таблице, в каждом из которых 3 ячейки
 	<table border="1" cellpadding="5">
		<tr>
			<td>1:1</td>
			<td>1:2</td>
			<td>1:3</td>
		</tr>
		<tr>
			<td>2:1</td>
			<td>2:2</td>
			<td>2:3</td>
		</tr>
	</table>
 */

// второй вариант той же таблицы:
$i = 1; // указывает с какого числа начинается отсчет
echo '
	<table border="1" cellpadding="5">
	<tr>';
while($i <= 3) { // повторяем ячейки 3 раза
	echo '<td>1:'.$i.'</td>'; // содержимое ячейки
	++$i; // увеличение переменной i на единицу
}
	echo '</tr>
		<tr>
			<td>2:1</td>
			<td>2:2</td>
			<td>2:3</td>
		</tr>
	</table>';

//третий вариант - мы так же можем использовать циклы в циклах:
// тут выводим на экран счет от 1 до 9 три раза с указанием порядкового номера цикла:
$i = 1; //начальные условия
$x = 1; //начальные условия
while($i <=3) { // количество циклов
	while($x < 10) { // цикл вывода цифр от 1 до 9
		echo $x; // вывод на экран цифры
		++$x; // следующее добавление +1 вплоть до 9
	}
	echo $i;
	++$i; // после прохождения цикла повышает $i на единицу: $i = 2
	$x = 1; // а $x сбрасывается до единицы: $x = 1, после чего цикл повторяется
	// пока не получим $i = 3, после чего цикл дойдет до конца и завершится
}
// вот что в итоге выведется на экран: 123456789112345678921234567893 (где 1,2,3 после 1-9 это $i)

//Пример ошибочного цикла:
$x = 10;
while($x < 10) {
	echo $x;
} // тут по результату ничего не ведет на экран, так как $x = 10 и не может быть < 10

11-2-3b // DO WHILE - аналогична while, только отличие, что в начале у нас в обязательном
// порядке первая интерация цикла, то есть первый вывод будет работать.
echo 'Перед циклом<br>';
$x = 1;
do { // do - что делать?
	echo $x.'<br>'; // выводится
	++$x;
} while ($x < 10); // обратить внимание мы местами поменяли действия с условием
echo 'После цикла';
//мы тут делаем определенное действие, пока выполняется условие
//первая проверка цикла проходит теперь не в начале цикла, как было при while,
//а после первого выполнения, то есть первая часть do выполнится всегда, даже если условие
// не удовлетворяет
1:23:40 / 1:57:27

11-2-3c //FOR
echo 'Перед циклом';
for($x = 1; $x <10; ++$x) {
	echo $x.'<br>';
}
echo 'После цикла';

// цикл в цикле
echo 'Перед циклом'; // приблизительно так нужно будет сделать домашку.
for($x = 1; $x <= 5; ++$x) {
	for($y = 1; $y <= 10; ++$y) {
		echo $x.':'.$y.'<br>';
	}
}
echo 'После цикла';

11-2-3d //FOREACH - используется для перебора массивов
$names = array('', 'Вася', 'Петя', 'Илона', 'Даша'); // наш исходный массив
echo '<pre>'.print_r($names,1).'</pre>'; // просмотр исходного массива, в коде не нужно писать - это для себя
//$k - ключ (сокращение от key), $v - значение переменной (сокращенное от value)
echo 'В нашем доме живут: <br>';
foreach($names as $k=>$v) {
	echo 'Квартира = '.$k.', Владелец = '.$v.'<br>';
}

//второй вариант (массив тот же):
echo 'В нашем доме живут: <br>';
foreach($names as $k=>$v) {
	echo $v.', '; // получили вывод всех имен в виде:"В нашем доме живут: , Вася, Петя, Илона, Даша,"
}
echo '</br>';

//третий вариант (меняем только способ вывода, но резельтат будет как в варианте два):
echo 'В нашем доме живут: <br>';
foreach($names as $k=>$v) {
	echo $names[$k].', '; // получили вывод всех имен в виде:"В нашем доме живут: , Вася, Петя, Илона, Даша,"
}
echo '</br>';

//Четвертый вариант - самый короткий без создания ключей (результат аналогичный второму):
echo 'В нашем доме живут: <br>';
foreach($names as $v) { // ключ в этом способе не создаем, только значение передаем, зато быстрее так обрабатывается
	echo $v.', '; // получили вывод всех имен в виде:"В нашем доме живут: , Вася, Петя, Илона, Даша,"
}
echo '</br>';

//Пятый вариант - перебор массива (ключ и значение задаем прямо в массиве):
$names = array('Name1'=>'Вася', 'Name2'=>'Петя', 'Name3'=>'Илона', 'Name4'=>'Даша'); // Name - ключ, Вася - значение
echo '<pre>'.print_r($names,1).'</pre>'; // просмотр исходного массива, в коде не нужно писать - это для себя
//$k - ключ, $v - значение переменной
echo 'В нашем доме живут: <br>';
foreach($names as $k=>$v) {
	echo $k.'=  '.$v.'</br>';
} //получим:
//В нашем доме живут:
//Name1= Вася
//Name2= Петя
//Name3= Илона
//Name4= Даша

11-2-4 // У всех четырех циклов есть специальные функции: break и continue;
// break - обрывает цикл;
$names = array('Вася', 'Петя', 'Илона', 'Даша');
echo '<pre>'.print_r($names,1).'</pre>';
foreach($names as $k=>$v) {
	if ($v == 'Илона') { // если цикл дошел в массиве до "Илона", то
		break; // то цикл останавливается
	} echo $v.', '; // на экран выведется только "Вася, Петя,"
}

// continue - заканчивает данную итерацию цикла;
$names = array('Вася', 'Петя', 'Илона', 'Даша');
echo '<pre>'.print_r($names,1).'</pre>';
foreach($names as $k=>$v) {
	if ($v == 'Илона') { // если цикл дошел в массиве до "Илона", то
		continue; // то цикл оборвется и "Илона" не выведется
	} echo $v.', '; // на экран выведется только "Вася, Петя, Даша,"
}


 Урок 12: //Домен и хостинг
//Хостинг
//Домен
//DNS
//Сайт hostinger.ru
//FTP-клиент Far
//FTP-клиент FileZilla
//Настройки сервера: phpinfo() - функция для просмотра версии php, программ, IP и прочего на сервере.
// Через этот сайт можно получить уязвимости сайта, поэтому после проверки удаляем со страницы


Урок 13: //Пользовательские функции
/*PHP имеет более 1000 встроенных функций, кроме того, вы можете создавать свои собственные пользовательские функции.
Функция — это блок операторов, который можно многократно использовать в программе.
Функция не будет выполняться автоматически при загрузке страницы.
Функция будет выполнена вызовом функции.*/

13-1 //Считаем количество элементов в массиве:
// допустим нам в одном коде нужно посчитать количество жильцов и стран в массивах, похожие действия
$array = array(
	'Петя', 'Ульяна', 'Даша', 'Маша', 'Денис',
);
$count = 0; // создание переменной, откуда начинается счетчик
//Подсчеты - счетчик жильцов
foreach($array as $v) {
	++$count; //count — Подсчитывает количество элементов массива
}
//вывод
echo 'В нашем доме живут ('.$count.') ';

foreach($array as $v) { //вывод массива на экран + добавление счетчика жльцов
	echo $v.', ';
} // получим на экране: "В нашем доме живут (5) Петя, Ульяна, Даша, Маша, Денис,"

//считаем количество стран в массиве:
$country = array(
	'Украина', 'Польша', 'Франция',
);
$count = 0;
foreach($country as $v) {
	++$count;
} echo 'Стран в массиве= ('.$count.') ';

/* Бывают коды очень большой длинны 1000+ строк и в нем может быть некоторый участок кода,
 * который будет повторяться в некоторых местах как в примере выше - подсчет жильцов и стран
 * в этом случае на помощь приходит функция. Они аналогичны с изученными инклюдами:
 * include 'text.php' - подставляем участок кода в определенный файл
 */
//Функция count:
$count = count ($array);
$count = count ($country);

//Еще одна особенность - нам не обязательно результат помещать в какую-то переменную, мы можем вызвать
//функцию прямо внутри кода:
$array = array(
	'Петя', 'Ульяна', 'Даша', 'Маша', 'Денис', 'Степан',
);
echo 'В нашем доме живут ('.count($array).'):';
foreach($array as $v) {
	echo $v.', ';
} // получим вывод: "В нашем доме живут (6):Петя, Ульяна, Даша, Маша, Денис, Степан,"


13-2 //Вызов (запуск) функции:
//Запомнить: страница php - это программа, а функция - это подпрограмма
//func (); - у разных функций свои названия
//Создание функции:
function count2 () { // называем count2, так как count уже было, а повторять нельзя
	// тут пишем тот код, который должна выполнять функция
	echo 'Произвольный текст из функции<br>';
} //дальше мы эту функцию вызываем:
echo 'Текст до функции<br>';
count2(); // подставится "Произвольный текст из функции"
count2(); // подставится "Произвольный текст из функции"
count2(); // подставится "Произвольный текст из функции"
echo 'Текст после функции';

/* у функции есть некоторые особености - переменные, котрые мы создаем за пределами функции - не существует внутрии функции
 * если перед function count2 строчкой выше прописать $var1 = 'text'; то эта переменная никак не повлияет на функцию.
 * с другой стороны если переменную новую разместить внутри функции, то она не будет выполняться вне функции
 * разберем на примере предыдущей функции:
 */
$var1 = 'text1';
function count2 () {
	//echo $var1; //ошибка
	$var2 = 'text2 ';
	echo $var2;
	echo 'Произвольный текст из функции<br>';
}
//echo $var2; //ошибка
echo 'Текст до функции<br>';
count2(); // подставится "text2 Произвольный текст из функции"
count2(); //
count2(); //
echo 'Текст после функции';
/*
 * Фцнкции полностью независимы. Хоть они и находятся в одном месте, все равно они друг друга не видят.
 * Функция должна быть независимой и всегда работать так как надо. Переменные с однаковым названием (если так получилось)
 * выполняются отдельно и не зависят друг от друга. Переменные внутри функции не видны за пределами функции. И те
 * что за пределами функции не видны внутри функции.
 */


13-3 //как передать переменную из-вне функции внутрь функции? Рассмотрим на примере $var1, для этого размещаем ее
// внутри круглых скобок (в коментах очередность действий выполнения):
$var1 = 'Степан'; // 1-е - задаем переменную
function count2 ($t1, $t2, $t3) { // 3-е отправляем на выполнение функции уже не $var1, а значение переменной $t1
	echo $t1.'<br>'.$t2.'<br>'.$t3.'<br>'; //4-е действие - выводим на экран
}
echo 'Текст до функции<br>';
count2($var1, 'Пантера', 2022, 2023); // 2-е переносим в этот код ($var1) кроме того прописываем новые, не извне
//count2(); // тут пришлось закоментить, потому что выдает ошибку
echo 'Текст после функции';
//2023 не выведется, так как в функции function count2 не введено переменную $t4 и в эхо ее тоже нет.
//если в функции убрать $t3 - выдаст ошибку, так как в функции передавать больше значений можно, меньше нельзя.


13-4  // разбираем что еще можно делать с функцией:
function hard ($num1, $num2) { //в круглых скобках передается аргумет функции. Вы можете добавить столько аргументов,
	// сколько хотите, просто разделите их запятой. Аргумент подобен переменной.
	$sum = ($num1*5+$num2*10)/2 - 1;
	$sum = 'Результаты подсчетов: '.$sum;
	echo $sum;
}
//затем в произвольном месте, не обязательно рядом, можно даже через 100-200 строк, потом вызываем нашу функцию:
hard(5,3);
// и смотрим результат: "Результаты подсчетов: 26.5" - расчет произведен.


13-5 // Улучшаем эту же функцию добавбляя новые условия выполнения через IF и ELSE:
function hard ($num1, $num2) {
	$sum = ($num1*5+$num2*10)/2 - 1;
	if ($sum <20) {
		$sum = 'Результаты подсчетов: '.$sum;
		echo $sum;
	} else {
		echo 'Слишком большое число у переменной (результат больше 20)';
	}
}
hard(1,3);
echo '<br>';
hard(30,40);


13-6 //О выводе на экран:
/*
 * Принято так, что функция не должна содержать вывод на экран, то есть echo не должно быть в функциях
 * Функции должны получать какие-то данные и возвращать какие-то данные. А заходим ли мы вывести какие-то
 * данные на экран мы должны уже сами решать.
 * Теперь как это происходит - напишем эту же функцию, только без вывода информации на экран:
 */
function hard ($num1, $num2) {
	$sum = ($num1*6+$num2*10)/2 - 1;
	if ($sum <20) {
		$sum = 'Результаты подсчетов: '.$sum;
		return $sum; // меняем echo на return
	} else {
		return 'Слишком большое число у переменной (результат больше 20)'; // меняем echo на return
	}
}
$temp = hard(1,1); // Результаты подсчетов: 7
echo $temp;


13-7 // сами пишем функцию, которая должна считать:
$names = array(
	'Петя', 'Ульяна', 'Даша', 'Маша', 'Денис', 'Степан',
);
function count2 ($names) {
	$count = 0; // теперь мы должны переменную $count посчитать
	foreach($names as $v) { // между ")" и "{" нельзя ставить ";" - сейчас поставил и потом искал пол часа ошибку!
		++$count;
	}
	return $count; // 6
}
echo count2 ($names); //6


13-8 // Обычно это все выводится проще, благодаря встроенным функциям:
$names = array(
	'Петя', 'Ульяна', 'Даша', 'Маша', 'Денис', 'Степан',
);
$count = count ($names);
echo 'итого '.$count.' имён'; // echo "итого .$count. имён"  - так тоже можно писать
// "итого 6 имён"


13-9 // разберем более сложные функции на примере задания из домашки (создать таблицу и окрасить ячейки в разные цвета):
function makeTable ($x,$y) { //здесь можно проставить цифры, но все равно если мы внизц в "echo makeTable (5,3);"
	// зададим другие цифры, то приоритет к исполнению функции отдастся цифрам из "echo makeTable (5,3);"
	$text = '';
	$text .= '<table>';
	for($i=1; $i<=$y; ++$i) {
		$text .='<tr>';
		for($i2=1; $i2<=$x; ++$i2) {
			$color = 'white'; // цвет всех ячеек
			if($i == 2 && $i2 == 3) {
				$color = 'red'; // ячейка 2:3 будет красная
			} elseif ($i == 2 && $i2 == 4) {
				$color = 'green'; // ячейка 2:4 будет зеленая
			} elseif ($i == 3) {
				$color = 'blue'; // третья строка будет синяя
			}
			$text .= '<td style="background-color:'.$color.';">'.$i.':'.$i2.'</td>';
		}
		$text .='</tr>';
	}
	$text .= '</table>';
	return $text; // return работает по аналогии с break - завершает выполнение текущей функции
	//return может возвращать только одну переменную!!! Если записать две через запятую, то выдаст ошибку.
	// но есть лазейка - можно вернуть несколько - массивом.
}
echo makeTable (5,3); // задаем количество столбцов и строк


13-10// Функция count
//count — Подсчитывает количество элементов массива или Countable объекте
count(Countable|array $value, int $mode = COUNT_NORMAL): int
//Подсчитывает все элементы в массиве, если используется массив. Если используется объект, который реализует
//интерфейс Countable, функция возвращает результат выполнения метода Countable::count().


13-11 //Функция preg_match
//preg_match — Выполняет проверку на соответствие регулярному выражению
preg_match(
    string $pattern,
    string $subject,
    array &$matches = null,
    int $flags = 0,
    int $offset = 0
): int|false
// Ищет в заданном тексте subject совпадения с шаблоном pattern.

13-12 // Функция по регистрации пользователя и проверки условий (это не регистрация, а просто пример функции):
function addToDB ($login, $password) {
	// Процедура добавления пользователя в общую Базу Данных
}
function reg ($login, $password) {
	if ($login == 'Vasya') { // Если логин 'inpost' совпадет с логином в базе 'Vasya', то
		return false; //в регистрации отказано
	}
	addToDB ($login, $password);
		return true; // регистрация прошла, добавили в базу
}
if (reg('Vasya', '123')) {
	echo 'Вы успешно зарегистрировались, поздравляем!';
} else {
	echo 'Такой логин уже есть в базе данных, вы не зарегистрировались!';
}


13-13-1 //Функция по вызову текста:
function textMake ($text) {
	$text = 'Разные '.$text.' и буквы'; // эта строчка привязывает переменную извне функции к функции
	return $text;
}
$text = 'слова'; // этот блок с переменными можно разместить и перед функциями, разницы нет
$text = textMake($text); // вызов переменной текст - тут можно в левой части вместо $text можно заменить на другую переменную
echo $text; // вывод переменной текст на экран
// вывод на экран: "Разные слова и буквы"

13-13-2 //Предыдущую же функцию можно сократить благодаря значку и: "&" перед переменой в функции - "склеивание переменных":
function textMake (&$text) {
	$text = 'Разные '.$text.' и буквы'; // убрали "	return $text;"
}
$text = 'слова';
textMake($text); // убрали переменную в левой части строки
echo $text;

13-14 /* Домашнее задание:
 * Сделать калькулятор. 3 входящих параметра:
 1. Первое число, 2. Второе число, 3. Действие (плюс, минус, умножить, поделить).
 * По примеру: function calc($num1,$num2,$action)
  * 4. Если $action не задан, то по умолчанию должно складывать переменные.
 */

 14 // Урок 14: Методы передачи данных GET и POST, работа с формами

 14-1 /* Формы - это блочные элементы, наподобие div, внутри которіх содержатся формы. Форм может быть несколько
на странице (пример: поле авторизации и поле регистрации). Формы сами по себе независимые.
*Атрибуты, которые есть у нас в форме:
1) action - указание файла, для отработки, этот атрибут указывать нужно всегда. Этот файл создаем заранее. Если мы хотим сделать отправку и обработку страницы на одной странице, а это лучший вариант для одностраничного сайта, то нам достаточно поле названия файла оставить пустым:
<form action="">
2) method - метод отправки переменных $_POST или $_GET: method="post" или method="get".
 $_POST и $_GET - это суперглобальные переменные, которые приходят из формы. Данные переменные
 пишутся таким синтаксисом.
 GET и POST - это наши два массива. Изначально они созданы пустыми. Это тожде самое, что если бы мы писали
 $_GET = array(); - так создаются пустые массивы
 Если мы передаем данные методом GET и POST, то эти массивы наполняются.
3) intime -
	*/

	echo 'GET: <pre>'.print_r($_GET, 1).'</pre>';
	echo 'POST: <pre>'.print_r($_POST, 1).'</pre>';
	?>

<form action="" method="get">
	GET	<input type="text" name="login"> <!--слово GET перед input отображает название поля ввода-->
	<input type="text" name="password">
	<input type="submit" name="submit" value="submit">
</form>
<!--можно сделать вообще две формы для каждого массива отдельно:-->
<form action="" method="post">
	POST	<input type="text" name="login"> <!--слово POST перед input отображает название поля ввода-->
	<input type="text" name="password">
	<input type="submit" name="submit" value="submit">
</form>

<?php
/* после этого на экран выведется:
GET:
Array
(
    [login] => roman.nik
    [password] => 1321
    [submit] => submit
)
POST:
Array
(
    [login] => inpost
    [password] => 3231321
    [submit] => submit
)/
Напомню, что [login] и [password] - это ключ переменной, а inpost и 3231321 - это уже значение переменной
*/

14-2  // Разберем еще пример - авторизация на сайте:
echo 'GET: <pre>'.print_r($_GET, 1).'</pre>';
echo 'POST: <pre>'.print_r($_POST, 1).'</pre>';
?>

<form action="" method="post">
	<input type="hidden" name="hide" value="скрытое значение">
	<div>Заполните логин:<input type="text" name="login"></div>
	<div>Заполните пароль:<input type="password" name="pass"></div>
	<div style="padding:15px">
		Пол: <br> <!--тег <label> используется для придания интерактивности тексту - можно включить кнопку нажатием
		 на текст "Мужчина"	так же label работает и с checlbox-->
		<label>Мужчина <input type="radio" name="gender" value="Мужчина"></label> |
		<!--в радио мы используем одинаковый тип и имя-->
		<label>Женщина <input type="radio" name="gender" value="Женщина"></label>
		<!--здесь value - это то что выведется текст в массив-->
	</div>
	<div style="padding:15px">
		Любимый напиток: <br> <!--так же label работает и с checkbox-->
		<label>Кофе <input type="checkbox" name="like[]" value="Кофе"></label> |
		<label>Чай <input type="checkbox" name="like[]" value="Чай"></label> |
		<label>Молоко <input type="checkbox" name="like[]" value="Молоко"></label>
		<!--в отличие от радио в чекбоксе при отправке данных выведется только последняя отмеченная запись.
		Чтобы этого избежать необходимо задать разные имена name (like 1, like2, ...) или записать в массив like []-
		создастся новый массив внутри массива $_POST
		Передачу данных в мссив возможна и в остальных местах, но в чекбоксе они обязательны-->
	</div>
	<div><input type="submit" name="submit" value="Отправить данные" style="border-style:hidden; border-radius:10px;
	background-color:#90ff90"></div>
</form>
<!--type ="button" в формах не используется, в основном в через JS делается.
тип = hidden - используется для указания кому отпарвляем остальные вводимые поля
name - это наш ключ переменной.
value - содержание значения данного поля
после каждой отправки данных страница перегружается и наново записываются данные в массив $_POST-->

<?php
14-3 //сокращенная форма работы с суперглобальной переменной и записью в массив:
echo '<p>Ваш логин: '.@$_POST['login'].'</p>'; // @ - этот значек убирает сообщения об ошибках.
?>
<form action="" method="post">
	<div>Заполните логин:<input type="text" name="login"></div>
	<div>Заполните пароль:<input type="password" name="pass"></div>
	<div><input type="submit" name="submit" value="Отправить данные"></div>
</form>

<?php
14-4 // Сокращенная форма для checkbox
echo '<p> Мы любим: '; //здесь как в примере 14-3 не получится одной строчкой сделать
foreach($_POST['like'] as $v) { // придется использовать foreach
	echo $v.','; // указываем выводить через запятую: "Мы любим: Чай,Молоко,"
}
/* освещим память - эту же функцию можно было бы написать и на основе того, что уже раньше учили:
$like = ''; // пустые ковычки - это пустота
foreach($_POST['like'] as $v) { // foreach используем для наполнения $like
	$like .=$v.','; // ".=" это мы переменную дописываем
}
echo '<p>Мы любим: '.$like.'</p>';
 */
?>
<form action="" method="post">
	<div style="padding:15px">
		Любимый напиток: <br>
		<label>Кофе <input type="checkbox" name="like[]" value="Кофе"></label> |
		<label>Чай <input type="checkbox" name="like[]" value="Чай"></label> |
		<label>Молоко <input type="checkbox" name="like[]" value="Молоко"></label>
	</div>
	<div><input type="submit" name="submit" value="Отправить данные"></div>
</form>

<?php
14-5 // Для проверки была ли отправлена информация после нажатия на кнопку в примере 14-2 на экран выводилось:
//"[submit] => Отправить данные"
// можно так же проконролировать отправку с помощью  функции isset:
	if(isset($_POST['submit'])) {
		echo 'Форма отправлена';
	}
// проверяем передались ли конкретніе данные, чтобы мы с ними работали

14-6 // Проверка для checkbox через isset:
if(isset($_POST['submit'])) {
	echo 'GET: <pre>'.print_r($_GET, 1).'</pre>';
	echo 'POST: <pre>'.print_r($_POST, 1).'</pre>';

	$like = '';
	if(isset($_POST['like'])) {
		foreach($_POST['like'] as $v) {
			$like .= $v.',';
		}
		echo '<p>Мы любим: '.$like.'</p>';
	}
}

14-7 // Чтобы защитить от взломов сайты нужна проверка авторизации с базой
if(isset($_POST['login'], $_POST['pass'])) { // эта часть не даст войти без заполнения форм
		//в связи с этим блок ниже не будет выполняться
	echo $_POST['login'];
	echo 'GET: <pre>'.print_r($_GET, 1).'</pre>';
	echo 'POST: <pre>'.print_r($_POST, 1).'</pre>';
}
14-8 /*Безопасность: любая ошибка - это потенциальная угроза взлома. Хакеры используют ошибки для взлома.
 Никогда нельзя доверять входящим данным. Если мы хотим сделать наш скрипт, который будет
 работать непосрадственно с логином и паролем, то мы должны проверить - были ли передан логин и пароль!
 Нужно ловить не нажатие кнопки, а ловим существование логина и пароля! Тогда мы сможем его вывести и
 поработать с конкретным логином и паролем.
 Главное правило - если мы работаем с логином - мы должны проверять существование логина,
 если с паролем, то существование пароля. И так со всеми данными.*/

//	При этом если нам нужны какие-то значения по умолчанию, допустим мы передаем логин и пароль, а остальные
//	разделы формы пользователь не заполнил, то можно сделать так:
	if(isset($_POST['like'])) {
		echo 'Человек любит'.$_POST['like'][0];
	} else {
		echo 'Человек ничего не любит'; // выведется на экран, если ничего не отметил в чекбоксе.
	}

14-9 // Безопасность: Любые переменные и данные которые мы сами заполняем - безопасные, напрмер:
$x = 10;
	echo $x;
/* А данные, которые запоняются из формы - суперглобальные $_POST и $_GET вот их заполняет клиент, их и нужно проверять. Если данные переданы правильно, то выполнять какие-то действия, а если неправильно переданы, то нужно вернуть его обратно на нашу форму.*/

14-10 // полный текст кода с проверкой авторизации:
if(isset($_POST['login'], $_POST['pass'])) {
	echo $_POST['login'];
	echo 'GET: <pre>'.print_r($_GET, 1).'</pre>';
	echo 'POST: <pre>'.print_r($_POST, 1).'</pre>';
	if(isset($_POST['like'])) {
		echo 'Человек любит'.$_POST['like'][0];
	} else {
		echo 'Человек ничего не любит';
	} echo "Вы успешно зарегистрировались";
} else {// если регистрация не прошла, то выполняется блок кода расположеного ниже - скобка открылась
?>
<h1>Форма</h1>
<form action="" method="post">
	<input type="hidden" name="hide" value="скрытое значение">
	<div>Заполните логин:<input type="text" name="login" value=""></div>
	<div>Заполните пароль:<input type="password" name="pass" value=""></div>
	<div style="padding:15px">
		Пол: <br>
		<label>Мужчина <input type="radio" name="gender" value="Мужчина"></label> |
		<label>Женщина <input type="radio" name="gender" value="Женщина"></label>
	</div>
	<div style="padding:15px">
		Любимый напиток: <br>
		<label>Кофе <input type="checkbox" name="like[]" value="Кофе"></label> |
		<label>Чай <input type="checkbox" name="like[]" value="Чай"></label> |
		<label>Молоко <input type="checkbox" name="like[]" value="Молоко"></label>
	</div>
	<div><input type="submit" name="submit" value="Отправить данные" style="border-style:hidden; border-radius:10px;
	background-color:#90ff90"></div>
</form>
<?php } ?><!-- скобка закрылась-->
<!--Лайфхак: Вставка большого кода html в php:
для того, чтобы вывести большой код html нам не обязательно писать echo '' (где внутри кавычек писать html код на много строчек). Достаточно закрыть закрыть php и дальше писать html, а в конце открыть php и закончили наше условие, как в примере выше <?php } ?> -->

<?php


14-12 /*различия между $_GET и $_POST - работа с ними полностью аналогична, нужно только указывать так же
 метод принятия в форме <form action="" method="post">. Абсолютно аналогичное действие, за исключением маленьких
 деталей.
 POST - это наши скрытые данные, засекреченные, когда мы данные отправляем на нашу страничку они отправляются,
 но мы их не видим куда отправились, то есть нигде не отображаются в нашем браузере. То есть наш массив передается в скрытом типе. Еще у POST можно передавать картинки.
 GET - метод передачи данных через адресную строку. При отправке методом GET мы получаем очень длинную адресную строку: /testphp1.ua/index.php?hide=скрытое+значение&login=132123&pass=1231231&gender=Женщина&like%5B%5D=Чай&submit=Отправить+данные
 - это строчка состоящая из ключей=значение, ... (+ это пробел)
  POST в адресной строке наши данные НЕ передает!
 Еще отличия:
 1) Методом GET нельзя передавать файлы,
 2) GET - ограничен по длине (нельзя передвать большие тексты - длинна поддержки зависит от браузера) - в последнее время эта проблема ушла с развитием браузеров.
 3) GET - виден на экране, в том числе и пароль, который в форме скрыт звездочками!
 4) Из плюслов: GET хорош при передаче ссылок из поисковых запросов: https://www.google.com/search?q=%D1%87%D1%82%D0%BE+%D1%82%D0%B0%D0%BA%D0%BE%D0%B5+php&rlz=1C1SQJL_ruUA888UA888&oq=%D1%87%D1%82%D0%BE+%D1%82%D0%B0%D0%BA%D0%BE%D0%B5+php&aqs=chrome..69i57j0i512l6j69i61.4942j0j1&sourceid=chrome&ie=UTF-8
 это ссылка из гугля запроса "что такое php".
5) GET - используется для навигации (использование ЧПУ, для SEO раскрутки)
*/

14-13 // Разбор домашки к уроку 13 и задание к 14 уроку:
function calc($num1, $num2, $action='plus') {

}
/*Домашка сделать форму:
1) два поля для ввода данных
2) 4 радио для + - * /
3) сделать кнопку "отправить"
4) вывести число (ответ) без разницы где вверху или сбоку: 5+10 = 15 (отобразить входящие данные, саму формулу и результат).
5) не забывать пользоваться проверкой isset входящих данных, чтобы существовало значение первое и значение второе
if(isset($_POST['num1'], $_POST['num2'])) {..} нужно ввести значение 1 и 2 и отправить в нашу форму*/



Урок 15: //Улучшаем качество кода, include+GET, Суперглобальные массивы
/*План:
Ошибки домашек
Создаем навигацию include + GET
Изучаем область видимости переменных
Константы
$_REQUEST, $_SERVER, $GLOBALS
Самостоятельно изучаем пакет функций*/

15-1  //Навигация с GET - разбираем домашку №15:
$_GET = 'index.php?page=contacts'// переменная GET - это то что у нас в адрессной строке+?page=какая-нибудь страничка
$_GET['page'] = 'contacts'; // это говорит, о том, что мы можем спокойно передавать данные, используя навигацию, используя наши теги ссылок.


if(isset($_GET['page'])){ //если страница существует
//echo '<h1>'.$_GET['page'].'</h1>';
} else { //если нет, то создастся
$_GET['page'] = 'index';
}
?>
<div id="header">
	Навигация:
	<a href="15.php?page=main">Главная</a> |
	<a href="15.php?page=history">Наша история</a> |
	<a href="15.php?page=contacts">Контакты</a> |
	<a href="15.php?page=aboutus">О себе</a>
</div>
<div id="content">
	<?php include $_GET['page'].'.php';?> <!-- '.php' нужно обязательно указывать-->
</div>
<div id="footer">
	Тут пишем копирайты.
</div>

<?php
15-2 // Обычные функции с обычными переменными:
$x=5; //если х=5, то выведется на экран 10, если другая цифра - то ошибку выдаст. В javascript это рабьотает по другому и функция выполнится
if($x==5) { /* если функция соотвествует условию, то функция создастся, если нет, то не создастся */
function test($x) {
echo ($x*2);
 }
}
test($x); // получим на экране "10"

// а вот другой пример - внутри функции и вне - одна и та же переменная:
$x=5; //задали, но внутрь функции она не попадет
function test($x) { //внутри функции переменная останется внутри функции
	$x=10;
}
test($x) // а на экран выведется "5"

15-3 // Суперглобальные фукнции - в отличие от предыдущего примера, где переменные
//выполняются только внутри функции или только вне суперглобальные действуют везде.
//мы можем задавать так же переменные:
$x=5; // - локальные переменные
echo $x; //если только это оставить, то выведется "5"

unset($x); //почемуто не очистила предыдущую переменную :)))
$x=7;

$x=10;
echo $x; //в этом случае уже "510"

//Мы так же можем создать константу с помощью define - это такая переменная, которая пишется без знака $ и которая не может быть исправлена дальше по коду.
define("CON", "Привет, мир!"); // мы создали функцию в глобальной области видимости
echo CON; //пишем без ковычек!
function test() {
echo CON; // интересно передастся ли константа внутрь функции?
}
test();// да вывелось на экран: "Привет, мир!Привет, мир!"
//данная константа видна и за пределами функции и внутри функции!

//Когда использовать константы? Например для счетчика - указать, что на странице прилюбых раскаладах будет выводиться только 12 новостей:
define ('NEWSONPAGE', 12);
for($i = 1; $i <=NEWSONPAGE; ++$i) {
echo $i.'<br>';//выводим новости 12 раз.
}
//если появится задача сделать 3 блока по 12 новостей, то просто копируем цикл for (3 строчки последние) еще два раза и всё.
for($i = 1; $i <=NEWSONPAGE; ++$i) {
echo $i.'<br>';//второй блок
}
for($i = 1; $i <=NEWSONPAGE; ++$i) {
echo $i.'<br>'; //третий блок
}
15-4 /*Кроме констант есть и другие способы вывода в глобальную область - глобальные переменные:
	1) $_GET;
	2) $_POST - эти переменные и так видны внутри функции и их не обязательно туда
 передавать, но по канонам програмисты считают что функции создаются для того,
 чтобы туда можно было передать какие-то значения и вернуть какие-то значения:*/
 functio test() {
	 echo $_POST['x'];
	 echo $_POST['y'];
	 echo $_POST['z'];
} test ();
 /* 3) $_FILES - сюда будет попадать все, что содежится в <input type="file"/>
 Разберем на примере одновременного использования всех трёх:*/
$_GET['page'];
$_POST['login'];
$_FILES['file'];
?>
<form method="post" action="" name="page">
	<input type="text" name="login">
	<input type="file" name="file">
</form>
<?php
/*  4) $_REQUEST - дубль от $_GET, $_POST - усложним задачу - у нас два запроса
GET и POSt с именем'page' */
$_GET['page'];
$_POST['page'];
$_POST['login'];
$_FILES['file'];

$_REQUEST = array(
	'page' <- $_GET // page пападет из GET
	'login' <- $_POST //login из POST
);
/* но в наших занятиях $_REQUEST использовать не будем, потому что работая
в наших скриптах мы должны делать полностью "прозрачной" нашу работу, так
чтобы это было очевидно - что за переменная, откуда пришла и что делает */

/*  5) $_COOKIE;
    6) $_SESSION; - работу куки и сессии мы разберем на отдельном уроке.
	7) $_ENV; - не будем вообще разбирать.
	8) $_SERVER;
	9) $_GLOBALS; - сегодня рассматривать не будем
расмотрим $_SERVER: */
echo '<pre>'.print_r($_SERVER,1).'</pre>'; // получаем полную информацию
// о сервере. Данную переменную в коде осталять нельзя, чтобы не отдать хакерам наш
// сайт. Так же нельзя показывать хакерам phpinfo();
//но есть и полезные фишки - можно блокировать айпи:
if($_SERVER['REMOTE_ADDR'] == '127.1.1.17') {
	echo 'Извините вам нет доступа';
}
//или наоборот запретить доступ не с нужного айпи:
if($_SERVER['REMOTE_ADDR'] != '127.1.1.17') { //настройка чтобы только у вас был доступ к серверу
	exit; //остановка скрипта
}

15-5 //Домашняя работа №15:
/*Завершить верстку макета и сделать рабочую навигацию с использованием include + GET. Сделать copyrights по виду:
2013 или 2011-2013 используя константу и функцию date().
Добавить в навигации еще один пункт меню "Админ панель или админ" и данную навигацию выводить только для пользователей
определенного IP. Кроме того внутри страницы main сделать проверку: if($_SERVER['REMOTE_ADDR'] != '127.1.1.17') ...
нужно заблокировать определенный IP адресс и выводить ссылку, то мы через эхо выводим ссылку на нашу страничку админки,
 если не совпадает, то на админку ссылку не выводим.
Так же самостоятельно изучить пакет проверок на php.net: isset, empty, is_array, is_bool, is_double, is_float, is_int,
 is_integer, is_null, is_numeric, is_real, is_string.
Приведение к типу: int, string, array, float.
*/
$var = 10;
$var = (int)$var;
$var = (string)$var;
// в домашке сделать тесты для себя:
$var = '1текст1';
echo (int)$var;
//еще протестировать:
$var = '1111';
$var = 'текст';
$var = 'текст2221';
$var = '1441текст';
$var = array ('пиво');
$var = (int)$var;
echo $var;

/* Еще выучить: Функции: gettype, count, include, include_once, require, require_once, rand, date */


Урок 16: //Фильтрация данных, $_COOKIE, $_SESSION

/*План:
Фильтрация данных
Безопасность при include
filter_var для адресов и email
int, float - для чисел
in_array для определённых множественных вариантов
$_COOKIE: Чтение, создание, редактирование и удаление
$_SESSION: Чтение, создание, редактирование и удаление*/

16-1 // Вывод ошибок
// Можно отключить в настройках: error_reporting(-1) поменять на ноль;
//Второй вариант отключение определенных ошибок - добавление знака @ - в то место, где может быть выведена ошибка
if (isset ($var)) echo $var; //иногда вместо такой записи пишут вот такую:
echo @$var; //если переменная будет, то она выведется, если нет, то вывод ошибок будет проглушон.

//Скрипт вывода ошибок: error_reporting(-1) можно в одном коде открывать и закрывать (меняя -1 на 0) по нескольку раз по мере необходимости.

//Обычно лезть настройки сервера нам никто не дает, поэтому для конкретного сайта в корне сайта создается файл:
//.htacess - для каждого сайта создается отдлельный файл!

//Разберем ошибки на примере домашки. В домашке у нас было так (? - это тернарный оператор):
$_GET['page'] = (isset($_GET['page']) ? $_GET['page'] : 'main');
include $_GET['page'].'.php';
//если не правильно будет указан файл или не найден, то воявится ощибка:
//"Warning: include(main.php): Failed to open stream: No such file or directory in..."

16-2 // Первое нам нужно не допустить возможности перехода по папкам и файлам через GET запрос - через редактирование url страницы, когда через точки и наклонную черту получают доступ к файлам, например:
test.ua/index.php?page=(сюда дальше хакер редактирует запрос и доходит до папок и файлов:)../../../inpost.zz.mu/index

16-3//46:20 Еще один вид хакерских атак - include-inject - позволяет подгружать файлы из соседних папок, которые есть в наличии, но подключать не нужно
// Второй вид инъекции: include-inject + upload-inject (сокращенно upload-inj)
// в файл картинки дописывается скрипт <?php echo $var; ? >, после чего при подключении этого файла через include запускается этот скрипт. Причем если подключить эту картинку через стандартный html: <img scr="file.jpg">, то скрипт не запустится.

16-4 //Когда мы делаем сайт, то он должен отвечать таким требованиям:
//1. Работает
//2. Безопасен
//3. Не имеет ошибок

16-5 // Приведение к типу - int, float - защита наших данных от передачи посторонних параметров.
//Для того чтобы в форму регистрации в поле ввода возраста вместо цифр не вписали что-то другое используется приведение к типу:
$_GET['id'] = (int)$_GET['id']; //id - это номер нашей записи, в дальнейшем мы поработаем с ним
//получается неважно какие данные получаем через адресную строку, в переменную мы получим уже обработанные,
// в нашем случае чистые числа

//Допустим для банковской системы, где имеем дело с передачей денег, то тут используем float:
$_GET['maney'] = (float)$_GET['money'] // тут даже если напишут в поле 5551515.145<php aendws... - все равно
// в переменную получим чистое число без мусора '5551515.145'

16-6 // Следующее нужно проверить точно ли нам передали нужные значения?
//Если мы подразумеваем, что через адресную строку 'page' мы можем передавать только 'main', то мы пишем:
if($_GET['page'] != 'main') { //если 'page' не равна 'main'
	exit(); // то мы обрываем наш скрипт
}
//То есть кто-то пытался через адресную строку ввести те значения, которые не допустимы на нашем сайте, и у него теперь это не выйдет.

16-7 //Существует третий вид проверок - встроенные функции в php
//Для того, чтобы работать с конкретной страницей, нам нужно быть уверенными, что были переданы какие-то конкретные параметры
if(isset($_POST['email'])) { //точно ли передан email?
	if(!empty($_POST['email'])) {// проверка - а не пустой ли email
	// обработка данных - заносим в базу данных или еще какое действие делаем
	}
}
//Бывают сложные проверки - действительно ли email ввели правильно? Есть ли @, name, domain, в домене точка должне быть .com например, ... Для этого используют встроенную функцию filter_var

//Что нам возвращает isset: true или false - существует или не существует переменная
// filter_var работает точно так же возвращет true или false.
// Если email внесен правильно, то true, если не парвильно, то false
// у этой функции есть набор фильтров: https://www.php.net/manual/ru/filter.filters.php
//как это все работает:
if(isset($_POST['email']) && filter_var($_POST['email'], FILTER_VALIDATE_EMAIL)) { //делаем проверку если у нас существует переменная $_POST['email'] и (&&) filter_var(название функции), то есть проходит валидацию переменная $_POST['email'], после чего указываем как мы будем фильтровать - проверим на email -  FILTER_VALIDATE_EMAIL - стандартная настройка из ссылки выше
	echo 'Все ок!'; //если все проверки полодительные выведется эта строка
}
?>
<form action="" method="post">
	<input type="text" name="email">
	<input type="submit">
</form>
<?php
//чаще всего функция filter_var используется для проверки адресной строки и email

16-8 // Не проще ли проверки такие делать через Java Script?
//JS делает на стороне клиента и если клиент захочет, то он не будет делать такую проверку, а php
// делает эту проверку на сервере, то есть данные уже пришли и клиент не сможет подделать данные

16-9 // Область допустимых значений - выводим три варианта допустимой страницы:
if($_GET['page'] == 'main' || $_GET['page'] == 'contacts' || $_GET['page'] == 'aboutus') {
	echo 'все хорошо!';
} else {
	exit ('Вы ввели недопустимые значения'); // завершаем через exit;
}
//если так делать, то проблемы с 'include-inject' отпадут, то есть в адресную строку не напишут какой-нибудь бардак и не смогут подключить сторонний файл, из-за того что мы заранее делаем проверку и определяем какое значение верное. Если хотя бы одно из этих значений верно, то мы работаем со скриптом. В противном случае мы можем его вырубить через 'exit '

//Данная запись она работает, но она длинная и не совсем красивая, лучше вариант через создание массива:
$allowed = ('main', 'contacts', 'aboutus', 'game1', 'program1');
if(!in_array($_GET['page'], $allowed)) { // подключаем проверку из массива через отрицание(!)
exit ('Вы ввели недопустимые значения');
}

//Проверка возраста + проверка наличия самой переменной:
$sex = array ('man', 'girl');
if(isset($_GET['sex']) && in_array($_GET['sex'], $sex)) { //проверили наличие самой переменной и сравнили данные с данными из массива
	//обработка анкеты
} else {
	$_SERVER['REMOTE_ADDR']; //узнаем с какого IP нас пытались взломать, обычно ломают пользователи сайта, поэтому через базу можно найти этого пользователя, по сессии, по кукам - это потом разберем.
	exit(); //запрос пытались подделать
}
?>
/* Html обычно в таком виде:*/
<select name="sex">
	<option value="man"> man</option>
	<option value="girl">girl</option>
</select>

/* но мы его переделываем в такой:*/
<select name="sex">
	<?php foreach($sex as $v) { ?>
	<option value="<?php echo $v; ?>"><?php echo $v; ?></option>
	<?php } ?>
</select>

<?php
16-10 // Сессии и куки - что это такое?
//PHP так устроен, что он не хранит данные из переменных и при обновлении страницы или когда код считается до самого конца переменная очистится. Если нам нужно удержать/запомнить какие-то данные исользуются сессии и куки - они привязываются к определенному пользователю - это не общие переменные, которые существуют между страницами.
//ооБаза данных взаимодействует с каждым отдельным пользователем и позволяет пользователям выводить конкретные данные.Базы данных будем изучать позже.
//Куки и сессии - это для конкретного пользователя переменные, а БД - это переменные доступные для всех.

// Куки и сессии - это созданные файлы в виде баз данных, в которых содержится набор переменных, это обычные наши массивы, аналогичные с $_GET, $_POST, $_SERVER

//$_COOKIE - находятся у клиента (к/к)
//$_SESSION - хранится на сервере (с/с)

//Клиент может править куки как он захочет, поэтому этим данным не стоит доверять. Так как куки хранятся у клиента, то в них нельзя размещат важную информацию. Содержимое куки можно прочитать и изучить пароли и другие вещи.
//Если сессии - это безопасно, то зачем тогда куки?
// У сессий есть стандартное понятие - очистка брошеннх сессий. Обычная сессия 22-23 мин(стандартные настройки сервера), если на протяжении этого времени сессия небыла исправлена, изменена, страничку на сайте не коткрывал, не обрабатывал, к ней не делали запросов, то сессия конкретного пользователя "умирает"
//Время жизни куки наоборот будет столько, сколько мы хотим
// Кроме того так как сессия хранится на сервере, то это дополнительная нагрузка, дополнительные данные, которые будут захламлять наш сервер. Если пользователей мало, то и сессии будут весить очень мало

//Без куков покупки которые мы переместили в интернет магазине в карзину, но не оплатили через 22 минуты, исчезли бы так как сессия разорвалась. С помощью куков мы можем продлить хранение данных о покупках на пол года или год и клиент через время сможет продолжить работу с магазином и купить товар.

16-11// Как подклюбчить сессию?
//Для подключения пишем в начале скрипта:
error_reporting(-1);
ini_set('display_errors', 'on');
header('Content-Type: text/html; charset=utf-8');
session_start(); // вот тут стартует сессия

/* Если сессии не включить, то мы не сможем работать с $_SESSION, а именно:
1. Добавлять данные
2. Читать данные
3. Редактировать данные
4. Удалять данные
*/

//Добавление данных:
$_SESSION['name'] = 'login';
//Для вывода логина на экран:
echo $_SESION['name']; // эти данные может подтянуться даже на другой странице, отличной ото той, где этот логин вводился. При переходах по страницам логин будет виден (если включено).
//Удаляются данные через функцию unset. Разберем пример:
echo '<pre>'; //для наглядности просмотр в столбик массива
print_r($_SESSION); //тут еще показывает наш логин
unset($_SESSION['name']); //удаляем из файла
print_r($_SESSION); //после обновления страницы - уже нет

//для очистки всей нашей сессии, чтобы ее не существовало, мы пишем:
session unset;
session_destroy();

16-12 // Куки
echo '<pre>';
echo 'SESSION: ';
print_r($_SESSION);
echo 'COOKIE: ';
print_r($_COOKIE);

$_SESION['name'] = 'inpost'; //эта строка должна была перенести логин того кто открыл сессию, но почему-то не вывело - вместо этого пишет в куки инфо про phpstorm

//в куках мы увидим:
//[Phpstorm-34e77593] => ab538db4-0e52-42d1-ab31-b8ebe378b55b
//[PHPSESSID] => 88ec249b378b1e21aa5eb57680853ec4 // - это идентификатор, название файла сессии, которая принадлежит конкретному человеку. Этот идентификатор создается автоматически и содержится в куках. Но тут появляется момент уязвимости - вирус ворует идентификатор сессии из куков в системе клиента и после этого имеют доступ к сессиям на сервере. Подделывая куки злоумышленник может попасть на сайт. Чтобы хакеры не воровали нашу информацию время сессии ограничивают до 22 минут.

//Куки хранятся в разных браузерах у разных местах:
// C:\Users\Ваше имя пользователя\AppData\Local\Microsoft\Windows\INetCookies (win10)
//C: \ Users \ user \ AppData \ Local \ Google \ Chrome \ User Data \ Default (Chrome)
//C: \ Users \ user \ AppData \ Roaming \ Mozilla \ Firefox \ Профили (Mozilla)
// C: \ Users \ user \ AppData \ Local \ Packages \ Microsoft.MicrosoftEdge_8wekyb3d8bbwe \ AC \ MicrosoftEdge \ Cookies (MS Edge)

//Добавлять данные, редактировать и удалять - можем только в период отправки заголовков,
// а читать данные - можно везде.
//Период заголовков будет существовать до первого echo в коде. Поэтому можем получить ошибку,
// если используем echo перед header('Content-Type: text/html; charset=utf-8') и session_start();

16-13 //Как создаются, редактируютися и удаляются куки?
//Создаем куки:
setcookie('name1', 'Roman', time()+60*60*24*30*12, '/');
// эта функция имеет 4 параметра: 1)ключ, 2)переменная, 3) время жизни куки (если ничего не указать, то быдет считать, что куки живут только сейчас, для увеличения времени после скобок добавляем + время в секундах, 4)'/'(ставится, чтобы кук работали по всему сайту).

//Редактируем куки:
setcookie('name1', 'NEW_MESS', time()+60*60*24*30*12, '/'); //кука умрет на стороне клиента
//путем замены имени
//Клиент не имеет достиупа к серверу, сервер не имеет доступа к клиенту

//Можно еще менять куки через переменную, но такой способ обычно не используется:
setcookie('name4', 'NEW_MESS', time()+60*60*24*30*12, '/'); // меняет у клиента
$_COOKIE['name4'] = 'AAAA'; //заменяет на сервере

//как убить куку:
setcookie('name4', 'NEW_MESS', time()-60, '/'); //ставим отрицательное время, что убивает куку у пользователя.

//Редактировать, добавлять и удялять куки (не сессии, а именно куки) можно до вывода информации на экран. Сессии можно в любой момент.

16-14 //Домашняя работа
/*
1-я домашка обязательна, 2 и 3 по жаланию.
1-я - на понимании куков и filter_var
2-я - на сессии и rand ()
3-я - на функции readdir и if-dir
*/


16-15// Домашнее задание №1 Форму для авторизации и выход

/*https://youtu.be/xxTMusbYpIk?t=4200
Делается достаточно просто, простая форма на ввод логина, пароли и email. Далее проверяем сначало на то, что заполнили поля, и email заполнили верно! После авторизации - запоминать ключ в куках. Выводить на экране. Для email: filter_var. Последнее поле меню: ВЫХОД!
Сделать простую форму авторизации. В прошлом уроке было выводить меню для определенных айпи адресов. Теперь добавить возможность по айпи либо для тех у кого прописан ключ, а ключ мы будем через форму авторизации: логин, пароль, емеил, войти. Если логин и пароль ввели правильно, то мы создадим куку с именем:*/
$_COOKIE['access'] = 1; //значит выводи меню ADMIN, то есть своего рода авторизация.
/*Если куки не существует, то мы проверяем айпи адресс. Если айпиадресс проходит выводим ADMIN, если айпи адресс не подходит, то мы не выводим айпи вообще
Задача простая - проверить форму, поработать с filter_var и поработать с куками. И добавим еще выход из кук, выход из админки меню ВЫХОД! Эта кнопка должна убить $_COOKIE['access'] через отрицательное число, то есть будет отдельно созданная страничка на которую человек перейдет и кук убьется.
Нужно учесть только что куки можно создавать только до вывода любой информации на экран, поэтому нажатие, всю обоработку данных, ее нужно делать в самом начале, нижний блок из кнопок обработки мы помещаем в index.php в верхний блок, до вывода html.*/
if (isset($_POST['submit_auth'])) {
	//
}
if (isset ($_GET[exit])) {
	// передается через index.php?page=main&exit=1 так мы сделаем выход
}
16-16// Домашнее задание №2 Битва алкоголиков (https://youtu.be/xxTMusbYpIk?t=4558)
/*Мини-игра, цель которой показать, что алкоголизм - это плохо. Мы создаём страничку game.php под игру. Создаются 2 персонажа, у обоих по 10хп (2 сессионных переменных), создаётся форма, где пользователь вводит число от 1 до 3 и отправляет запрос на сервер. На сервере запустить rand(1,3), и если значение человека со значением случайным совпадает, то снимаются ХП с персонажа человека (клиента), если не совпадают - с серверного персонажа. Отнимать надо от 1 до 4хп, случайным образом). То есть вероятность 33%, что отнимутся у клиента, и 66%, что у серверного персонажа.
В момент, когда у одного из персонажей ХП становится 0 и ниже,- перебрасывать на другую страницу при помощи переадресации (header) на страницу gameover.php, и выводить текст, победил ли игрок, или система.

Цели игры: разобраться в сессиях и переадресациях. Попробовать на практике изученную самостоятельно функцию rand();*/
if(!isset($_SESSION['client'])){//если клиента не существует, то создаем ниже
$_SESSION['client'] = 10;
$_SESSION['server'] = 10;
}
/*далее через форму мы вводим число от 1 до 3, если число не совпало с rand(1,3), то мы выиграли у компьютера отнимая от 1 до 4 хп
После победы происходит перенос на новую страничку, для этого используем функцию:*/
header("Location: index.php?page=game1over&action=lose"); //функция переадресации на новую страницу
/*Еще с header("Location...") используется exit;*/


16-17// Домашнее задание №3 Файловый менеджер
/*Простая файловая система на подобии norton-comander, far, FileZilla с упрощенной версией.
Её путь будет: program.php .
Необходимо:
1) вывести каталог папок и файлов для данной директории, используя scandir('.'). Перед названием выводить иконку папки, или иконку файла соответственно. Проверку делать на: if(is_dir()) - else.
2) Папки сделать кликабельными, через ссылку передавать второй аргумент - путь к файлу по примеру: <a href="/program.php&link=echo (isset($link) ? $link.'/'.$v :$v);">имя папки</a> . Данный путь будет содержаться в массиве после использования функции scandir.
3) По переходу по ссылке будет передаваться $_GET['link'], который необходимо будет подставить в функцию scandir для того, чтобы отобразить файлы и папки внутри конкретной директории.
4) Таким образом мы сможем воссоздать файловую систему и передвигаться по директориям и поддиректориям.

Цели программы: изучить новые функции + цикл с массивом и множества аргументов для $_GET.*/
1:22:41 / 1:45:45
scandir('.') //анализирует данную папку
scandir('./1')//то анализируем папку '1'
//в файловой системе идем только вглубь, назад возвращаться не нужно.

Урок 17: Ядро, структура сайта, MVC
/*План:
	Архитектура сайта
	Ядро
	Структура сайта
	MVC
	Шаблоны*/

17-1-1 //Настройка файла index.php
error_reporting(-1);
ini_set('display_errors', 'on');
header('Content-Type: text/html; charset=utf-8');
session_start();

//конфиг сайта
include_once './config.php';
include_once './libs/default.php';
include_once './variables.php'; //- для работы с нашими переменными

//роутер - распределение между страницами, что мы будем подключать:
include '/modules/'.$_GET['module'].'/'.$_GET['page'].'.php';
include '/skins/'.SKIN.'/index.tpl'; //главную страницу подключаем (используем переменную SKIN из config.php)
//в index.tpl (это тут все от <!DOCTYPE html> до </html>)- подключаем в html код в раздел

17-1-2 //index.tpl
?>
<title><?= echo @$title; ?></title> <!-- для вывода разного содержания для разных страниц с помощью контроллера будем доставать эти данные из базы данных-->
<body>
<?php
include $_GET['module'].'/'.$_GET['page'].'.tpl';
?>
</body>

<?php
17-2-1 //страница с конфигурациями: config.php:
//задаем настройки сайта (всего сайта, а не страницы) через константы:
define('CREATED', 2013);
define('SKIN', 'default'); //шаблон - default
//define('NEWSONPAGE', 12); //12 новостей на странице
//подключаем базу данных:
define('DBLOGIN', 'inpost');
define('DBPASS', '123');
define('ADMINLOGIN', 'roman');
define('ADMINPASS', '123123');
//здесь будем хранить: соединения с базами данных, адресс нашего сайта и прочее

17-2-1 // страница variables.php
//задаем допустимые названия страниц, чтобы защититься от взлома:
$allowed = ('main', 'contacts', 'aboutus', 'game1', 'program1');

if(!isset($_GET['module'])) {
$_GET['module'] = 'static'; //папка "modules/static/" c файлами: contacts.php и .tpl, main.php и .tpl,...
} elseif (!in_array($_GET['module'], $allowed)) {
// подключаем проверку из массива через отрицание(!)
header ("Location: /index.php?module=404"); //вывод информации, что страница отсутствует
exit ();
}
if (!isset($_GET['page'])) {
$_GET['page'] = 'main';
}

17-3 // страница с конфигурациями: .htaccess
AddDefaultCharset UTF-8
php_flag display_errors ON

17-4 // библиотеки/ модули: папка modules
//в нее добавляем все классы, функции, пагинатор (навигация по страницам - внизу экрана 1, 2, ...898), аплоадер картинок - все делаем отдельными файлами с понятным названием

17-5 //папка с функциями: libs в ней создаем файл default.php - здесь будем записывать стандартные функции, которые будут использоваться везде, на всем сайте.

//для примера разберем функцию, которая будет выводить на экран массив - для мониторинга нескольких массивов
function wtf($array, $stop=false) {
	echo'<pre>'.print_r($array,1).'</pre>';
	if(!$stop) {
		exit();
	}
}
//вызов функции:
wtf($array,1);
wtf($array2,1);
wtf($array3); //тут 1 не прописали, значит false и функция остановилась

17-6 //MVC - Models (набор функций, базовое ядро) View (Вид, Представление) Controllers (Обработка данных) - размещать их нужно в разных файлах.
//За вывод информации отвечает верстальщик и СЕОшник, он определяет что где и как выводить, а Controllers - это уже часть программиста

//Controllers: отсутствует вывод на экран!

//Models: в 99% случаев не выводим на экран информацию через echo!
// используем return 'переменная или значения' возвращаем в контроллер и редко когда в представление

//View: весь вывод информации на экран + частичное php (echo $var; циклы, htmlspecialchars, приведение к типам - echo(int)$var;)

//1-й вариант разделения:
include $_GET['page'].'_controllers.php'; // 'news_controller.php'
include $_GET['page'].'_view.php'; //'news.view.php'
//2-й вариант разделения:
include $_GET['page'].'.php';
include $_GET['page'].'.tpl'; // tpl - изобрели для верстки
//3-й вариант разделения - реже всего используется:
include $_GET['page'].'.php'; //'news.php'
include $_GET['page'].'.html'; // 'news.html'

//4-й вариант - мы будем использовать его - это 2-й вариант + разбивать по папкам:
include '/modules/'.$_GET['page'].'.php';
include '/modules/'.$_GET['page'].'.tpl';

//примеры модулей:
//all_news.php - показать все новости
//view_news.php - просмотр одной новости в расширенном виде с комментариями пользователей сайта
//search_news.php - поиск по новостям

//но более понятно будет если называть по другому - первая часть - общая, дальше различия:
//news_all.php
//news_view.php
//news_search.php
//voting_all.php
//voting_once.php
//voting_last.php

//если на сайте планируется очень много модулей, то тогда лучше группировать их по отдельным папкам:
//news/all.php
//news/view.php
//news/search.php
//voting/all.php
//voting/once.php
//voting/last.php

//Примеры подразделов в папке модули: news, static, voting

17-7 // skins и подпапка default - папка с шаблонами: index.tpl - в него перенести весь html код с index.php.
include '/skins/default/index.tpl'; // это записать в index.php
//И такую же запись продублировать в body файла index.tpl

17-8-1 //404.php - создаем для ошибок отдельную папку 'modules/errors'( потом можно сюда добавить ошибки 403 и 500)
header("HTTP/1.1 404 Not Found");

17-8-2 // 404.tpl- создаем для ошибок отдельную папку 'skins/errors'
"Данная страница отсутствует!"


Урок 18: //База Данных MySQL. Основы
/*	План:
	Как всё устроено
	Создание БД
	Создание пользователя
	localhost
	Создание таблиц
	Частичная настройка и оптимизация таблиц*/
//https://youtu.be/a_DoWa7B6w8?t=1409/

18-1 // phpMyAdmin
//доступен по ссылке: http://localhost/openserver/phpmyadmin/index.php
//пароль и логин: root

18-2 // База данных - это массив, который хранится, выдается между страницами и эти данные общие для всех, каждый
// может получить доступ к этим данным. В отличии от сессии и кук. Потому что куки содержатся у клиента на
// компьютере, сессии содержатся на сервере, но при этом другие пользователи к ним не имеют доступа без
// определенного идентификатора, который знают только куки, которые содержатся у пользователя на компьютере.
//
?>
















